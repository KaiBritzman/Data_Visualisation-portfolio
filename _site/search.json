[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Data Visualisation",
    "section": "",
    "text": "This website has been designed to teach you about data visualisation in R, more specifically ggplot. R is a programming language that is used for statistics. GGplot is a library within R that lets us utilise the grammar of graphics. The grammar of graphics is a structure that is used to make complex graphs. Data visualisation is presenting your data in a visual form. If you own a huge company, you may make graphs to show how much money you made over the fiscal year. This is data visualisation. You have data on your revenue earnings, then you present it on a graph. This data could show you had a slow start of the year, but then got better towards the end. This is shown in your data visualisation. Instead of speaking about it, you can show people it instead. In the data science world, data visualisation is a rare skill. Many data scientists can use the data, but can’t present it well. So, this website will do that. It will cover data visualisation, covering specifications, the grammar of graphics, how complex graphs look and how choosing different components can change how data is shown and how animation can be used to elevate your graph."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "planning_a_specification.html",
    "href": "planning_a_specification.html",
    "title": "Planning a Graphic",
    "section": "",
    "text": "Planning is an important component for everything. Plans are outlines that you follow to make your intended product. For example, most buildings in the world have been planned in some way. Architects need to discuss what the purpose of the building is, and with that in mind, how do they design it to fit this need? They then need to plan where the building is going to go, and what materials and machines they need. A lot of planning goes into making a great building. This is the same for graphics. Having a specification (plan) will help lay foundations of what to include in the graph. Without plans, you may forget your original idea, you have no physical checkpoints to check off, so you have no accountability and everything isn’t thoroughly thought through yet. I will now explain what makes a good specification for a graphic and provide an example with the principles of what makes a good specification"
  },
  {
    "objectID": "planning_a_specification.html#introduction",
    "href": "planning_a_specification.html#introduction",
    "title": "Planning a Graphic",
    "section": "",
    "text": "Planning is an important component for everything. Plans are outlines that you follow to make your intended product. For example, most buildings in the world have been planned in some way. Architects need to discuss what the purpose of the building is, and with that in mind, how do they design it to fit this need? They then need to plan where the building is going to go, and what materials and machines they need. A lot of planning goes into making a great building. This is the same for graphics. Having a specification (plan) will help lay foundations of what to include in the graph. Without plans, you may forget your original idea, you have no physical checkpoints to check off, so you have no accountability and everything isn’t thoroughly thought through yet. I will now explain what makes a good specification for a graphic and provide an example with the principles of what makes a good specification"
  },
  {
    "objectID": "planning_a_specification.html#what-makes-a-good-specification",
    "href": "planning_a_specification.html#what-makes-a-good-specification",
    "title": "Planning a Graphic",
    "section": "What makes a good specification?",
    "text": "What makes a good specification?\nA good specification is specific with its planning, and thinks about all constraints and limitations. It thinks about all the components you need to make your graph. It will also answer lots of questions about design choices and explain things concisely enough that someone can read your specification, and make a graph exactly, or very close to what you intended with any software/tools. One thing specifications should include is the grammar of graphics. The grammar of graphics is a structure which visualisers should follow to make a graph that makes sense. Its like language structure. Back in school, we learn grammar, which teaches you where to place commas and full-stops when writing and how to make sentences make sense. This is the exact concept of the grammar of graphics.\nYour first section should be dedicated to the purpose of your graphic and what question you want it to answer. For example, you may be collecting data on user experience for UX design. You may want to answer the question “what designs do users like the most, and which ones do they like the least?”. Having this purpose will let you decide what you want the whole graph to look. The type of your data your working with to make your graphic, will also influence the rest of the components of your graph. Some components are only possible with certain types of data, so making sure you know the purpose of the graph, and what question you want to answer, will provide a foundation of what to include in your graph. This section should be clear and provide what story you want to tell with your data.\nThe rest of the sections will be design based, meaning it will include components you need in graph. This is where you should follow the grammar of graphics. The first component of the grammar of graphics is data. Data is the foundation of all graphs. Its what will be shown on the graph, and its what you use to tell your story. For your data, you need define the variables you have collected. If you are looking to make a graph about employee retention, you should include all the data you have like names of employees, how long they worked there, when they worked there and maybe their salary. Once you have this, you will know exactly what other components you can use in your graph. Some components can only be used with some data, like how probability is only for data that is numeric/continuous. So, having this known will make the rest of the specification easier. So, you need list all the variables then include what kind of data it is like categorical data or continuous data. For example, names would be categorical, years of employment would be continuous, when they worked there would be continuous and their salary is continuous. Here you could also cover transformations. These are changes to your data to summarise it. This can include means, counts and ranges. You would explain why you need these.\nThe next section of your specification is aesthetics. This where you plan what you want shown on the graph. For example, this is where you explain your x and y axes, what colours you want to use etc. You should be clear on what data you want using in your graph and explain why. This is the first major design question you answer. The aesthetics are what will be placed on the graph, so they are a huge component to how a graph looks.\nNext you should explain geometries. You will explain what geometry you want to use and why. You should say why a specific geometry is needed. It could be because the data you have best fits a certain geometry, or it because it allows you tell a specific story you want. For example, you may choose points because it will allow you later to make them bigger as the values get bigger, which can enhance your message because viewers can see a physical impact of something increasing or decreasing. Also, while having a clear and documented reason why you chose a geometry, you can get feedback for when the graph is made to make sure viewers will interpret your graph the way you want it to. Your mind can be deceived because it knows what the graph is intended to show, so you might not catch something wrong with it that can lead to viewers misinterpreting the graph. You can also explain statistical elements. These are the visuals of transformations to data. If this is explicable to your graph, you should do the same as you did for the raw data geometry. Explain what statistical element you want, and why you have chosen it. This will give you a vision that you can use to make sure your graph follows your specification well.\nYour next section should cover scales. Scales are visuals of our data. Geometries draw our data-points, scales are how we want our data to be shown visually. You should explain clearly and concisely, what scales you want including and why. Explain how they enhance the graph and why they are needed to make your graph how you want. Don’t specific lines of code you want to use. This is because code like scales_y_coninuous is exclusive to ggplot. Ggplot is a library within R studio that was made from the grammar of graphics. However, not having code will improve reproducibility. This is because there are a variety of tools that people use, not just ggplot. Those tools will have different syntaxes and rules. So, making sure that you don’t cover tool exclusive code will make sure that it can be reproduced no-matter the tools you are using.\nYour next section should be coordinates. Again, you need to be concise with what coordinates you want and why you need them. You should explain what coordinates you will need, like Polar or Cartesian coordinates. You should explain why you need them and how you plan to use them. You should try and explain the exact positioning you want. You can do this in a variety ways. You can explain in words if you want to zoom in on a specific part of the graph. You can also use images to show the positioning and explain why you want it there.\nThe final section should then be explaining guides. You need to explain the title of your graph, and what you want to name your x and y axes and your legend if applicable. You don’t need to necessarily explain why you chose your title and x and y axes names, because that can be self-explanatory given you previously explain the purpose and question your graph is answering. The legend can be changed position however, and that can have some explanation. This could be for readability or for purely aesthetic reasons.\n\nOverview\nA common theme with all the sections is explaining things in depth and giving reason. This lets you think about what you are planning, and this can let you discover flaws early on, rather than later in development. It also gives you checkpoints and visions your final graph should have. It will also make the graph reproducible by someone who has read your specification."
  },
  {
    "objectID": "planning_a_specification.html#example-specification",
    "href": "planning_a_specification.html#example-specification",
    "title": "Planning a Graphic",
    "section": "Example specification",
    "text": "Example specification\nBelow is an example specification for a graph for a data-set on weather over the last 5 years. This will have all the sections as discussed above with the depth and explanation needed:\n\nPurpose of graphic\nGlobal warming has been an issue for decades now. It has caused un-predictable weather events that cause lots of destruction. Lots of people however don’t think about it, or think it won’t affect them in their lifetime, so they do nothing about it. In order to tackle this, i have a data-set that has data on weather across every country in the UN. This will open the eyes of people who deny global warming, and to show the scale of it now, and paint a picture in peoples heads that if it carries on, this already destructive weather will get worse. The question i want my graph is answer is “How has the weather changed over the past 5 years?”. I have data on weather from January to December for 2020 to 2025.\n\n\nData\nWhat data do I have? I have data on the average temperature across the whole month for 5 whole years. These are the years between 2020 and 2025. I have chosen to get such recent data because it will show how it is now, not how it was in the past. Other graphs showing weather change are from the 1990’s to now. I want to show how its changed in the current decade. People may think if they see data from years ago and think “that was 30 years ago, it wont be another 20 or 30 years until its uncontrollable”. If they see more short-term damage, they will be aware its much sooner then they think until its completely uncontrollable. The type of data i have is continuous/numeric. The variables will include year, which will have 2020, 2021, 2022, 2023, 2024 and 2025. I will then have a month variable, which will include all the months of the year. I will then have a temperature variable, with the average temperature for each month.\n\n\nAesthetics\nFor aesthetics, my x axis will be the months of the year and the y axis will be temperatures. Then, each month will have a bar for each year going up to the average temperature of that month for that year. I also plan for colours to be associated with year. This means that each year will have a specific colour. For example, all data that is associated with the year 2020 could be red, all data for 2021 green etc. I chose to have bar charts because it will be easier to read. If i did points, it would be much harder to decipher which points are for what year. They may also over-lap and be really close together which can make it hard to look at and analyse.\n\n\nGeometries\nAs mentioned before, my geometry would be bars. This will mean each year will have a separate bar to display the average temperature. I have chosen this because its the most fitting. A histogram wouldn’t work because it focuses on singular variables, rather than multiple. So, a barchart is a better fit. Also, since I’m doing multiple bars for one data-value, having them touch for every month will make it confusing for the viewer to know which ones are for what month. Lines won’t work because it will cause overplotting, meaning lines for one month will cover the other. This is will make it unreadable, and make it hard to notice trends.\n\n\nScales\nScales are how data is visually seen. We just declare what we want shown in aesthetics, they don’t place them. Scales let us decide how we visualise our aesthetics. The scales i will apply is reordering data. For the months data, they can sometimes be shown in alphabetical order, so i will rearrange the data so the months appear as they do on the calender (January, February etc). I have chosen this so the data is easier to follow. If it was in alphabetical order, viewers would find it hard to read the graph because most people are used to the calender order of the months. I won’t apply any other scales. This is because i want to show people the raw data and just how it is. I don’t want people focused on specific data areas, i want viewers to see the whole thing, as it is. It will also look better for the general viewer.The general public may not want to see a complex graph. They may see the graph as more for professionals, so they wont look at it.\n\n\nCoordinates\nFor coordinates, i won’t apply any. Doing anything extra wouldn’t benefit the graph. For example, i can’t apply polar coordinates because they create pie-charts, so it wouldn’t match my vision because pie charts are comparing values to a complete value. Since we are working with temperature, there isn’t a total value, so a pie chart wouldn’t work. Including fixed coordinates, which are coordinates that are set in stone once applied, meaning that the graph won’t be distorted if anything else is applied, like a transformation. Since however I’m not applying a transformation that will make including a fixed coordinate make sense.\n\n\nGuides\nFor guides, the title of the graph would be “Average temperature for the past 5 years”. This a title that easily explains what the viewer is looking at. It’s not too long or has complicated words or abbreviation of words that the average viewer may not know. I will also label my x axis to be “Months” and the y axis to be “Temperature (degrees Celsius)”. I have added the “degrees Celsius” so people know what it’s measured in. Other parts of the world use Fahrenheit, which is a completely different scale to Celsius. I will also rename the legend to “Years”. This is so people know that the legend is to show the colour for each year. I will also adjust the size of the title of the graph. This is so the graph can catch more peoples attention. It will also bring more attention to what the graph is about. Viewers may not see a smaller title, so they will look at the graph, get confused then look at the title. However if the title is big, people will know immediately what the graph means, rather than guessing."
  },
  {
    "objectID": "planning_a_specification.html#why-separting-specification-from-execution-improves-reproducibility",
    "href": "planning_a_specification.html#why-separting-specification-from-execution-improves-reproducibility",
    "title": "Planning a Graphic",
    "section": "Why separting specification from execution improves reproducibility?",
    "text": "Why separting specification from execution improves reproducibility?\nSpecification is the planning, execution is actually producing the graph. With execution, this is where we open our graphic software and actually do the code to make it. We follow the specification we write and we make our intended graph. However, when writing your specification, you can’t combine it with execution. This is because different graphical software and tools has its own limitations and functions. If you think about how to make it in for example ggplot and R studio, the things you do may not be possible on other software or tools. You need to mention generic things, not anything specific. The grammar of graphics is a good example of reproducibility. The grammar of graphics is structure for a graph, not something exclusive to a tool or software. So, using this framework for your specification allows for reproducibility."
  },
  {
    "objectID": "planning_a_specification.html#references",
    "href": "planning_a_specification.html#references",
    "title": "Planning a Graphic",
    "section": "References",
    "text": "References\nLeland Wilkinson (2005) Statistics and computing: The Grammer of Graphics (Second Edition). New York; Springer\nUniversity of Colorado Boulder (2021) A Grammer of Graphics. Available at: https://www.youtube.com/watch?v=RCaFBJWXfZc (Accessed: 07/01/2026)\nhttps://vle.harper-adams.ac.uk/course/view.php?id=287 (07/01/2026)\nhttps://vle.harper-adams.ac.uk/course/view.php?id=287 (08/01/2026)\nAI has been used in this document (Used for researching and structure for specification)"
  },
  {
    "objectID": "grammar_of_graphics.html",
    "href": "grammar_of_graphics.html",
    "title": "Explaining the Grammar of Graphics",
    "section": "",
    "text": "The grammer of graphics is a set of rules that are followed when creating a graphic in R. When you are programming in R to make a graph, you need to declare each part of the graphc in a specific order to create the graph exactly how you want it. Its like the language strucutre of a new language. For example, in english, we follow the subject - verb - object rule. This means that we first declare a subject, then the verb and object. For example, “You eat apples”. “You” is the subject, “eat” is the verb and “apples” is the object. Since we followed the subject-verb-object rule, the sentence makes sense. This is the same idea for the grammer of graphics. The order we go in to make a graphic is R is data, aesthetics, scales and transformations, geometries and statistical elemetns, coordinates and then guides and facets. If we did this in another order like coordinates, scales and transformations then aesthetics, it wont work because we didnt follow the rules the grammer of graphics set. To make a graph that follows the grammer of graphics, you need a library called ggplot. This was made to follow the grammer of graphics and allows programmers to make detailed graphics. Within ggplot, you declare functions like aes() data(). Each function is a part of the grammer of graphics and they need to be delcared in the order discussed above."
  },
  {
    "objectID": "grammar_of_graphics.html#what-is-the-grammer-of-graphics",
    "href": "grammar_of_graphics.html#what-is-the-grammer-of-graphics",
    "title": "Explaining the Grammar of Graphics",
    "section": "",
    "text": "The grammer of graphics is a set of rules that are followed when creating a graphic in R. When you are programming in R to make a graph, you need to declare each part of the graphc in a specific order to create the graph exactly how you want it. Its like the language strucutre of a new language. For example, in english, we follow the subject - verb - object rule. This means that we first declare a subject, then the verb and object. For example, “You eat apples”. “You” is the subject, “eat” is the verb and “apples” is the object. Since we followed the subject-verb-object rule, the sentence makes sense. This is the same idea for the grammer of graphics. The order we go in to make a graphic is R is data, aesthetics, scales and transformations, geometries and statistical elemetns, coordinates and then guides and facets. If we did this in another order like coordinates, scales and transformations then aesthetics, it wont work because we didnt follow the rules the grammer of graphics set. To make a graph that follows the grammer of graphics, you need a library called ggplot. This was made to follow the grammer of graphics and allows programmers to make detailed graphics. Within ggplot, you declare functions like aes() data(). Each function is a part of the grammer of graphics and they need to be delcared in the order discussed above."
  },
  {
    "objectID": "grammar_of_graphics.html#aesthetics",
    "href": "grammar_of_graphics.html#aesthetics",
    "title": "Explaining the Grammar of Graphics",
    "section": "Aesthetics",
    "text": "Aesthetics\nAesthetics are an esstential part of the grammer of graphics. They are what you are going to see on the graph. Examples are the x and y coordinates and colours you will see on the graph. When coding, aesthetics are declared using:\naes()\nThe code is the written within the parenthesis. A common misconception about aesthetics is that the code within your parenthesis draws what you want onto your graph. However, they are just instructions, they don’t draw anything on the graph. Other components of the grammar of graphics are used for projecting the aesthetics however you want (scales and transformations, coordinates etc). Aesthetics are primarly built on attributes.\nThe main attribute is position. This refers to what you want your x and y coordinates to be. This is essential for a graph to work. This is because the x and y coordinates are the data you are using to tell the story you want. For example, to tell the story of the rise, fall and rise of the COVID 19 pandemic, you will need suitable data to convey this. You could use total number of cases on the y axis(the line going upwards) and a timeline for the x axis (the line going across). This will allow you to show the initial rise in cases, then the slow fall and show them rise again. Without the x and y coordinates, its very hard, and most of the time impossible to convey a story that can be told from a simple glance. To declare the x and y coordinates, you need write code similar to:\n\nlibrary(\"ggplot2\")\n\nWarning: package 'ggplot2' was built under R version 4.5.2\n\ndata(\"iris\")\nggplot(iris, aes(Sepal.Length, Sepal.Width)) +\n  geom_line()\n\n\n\n\n\n\n\n\nHere, i have declared my data-set. This is only necessary is you want to use your own data-set. If you are using a built-in data-set, like iris, you don’t need to declare it. I then declared ggplot, and within brackets, i declared my data-set, then used the aesthetics attribute. Then within parenthesis, i declared my x and y axis. Sepal.Length and Sepal.Width are like headings within the data-set. They have values associated with them, and ggplot uses them values to display your axis. You can rename your x and y axis but this is later within the grammar of graphics structure.\nWhy is position important? As stated previously, positions are needed so you actually plot data. It tells ggplot exactly what data you need to plotting and where to position the data on the axis. This is a component that is needed in every graph. You won’t always need other aesthetic attributes or other parts of the grammar of graphics for some really basic graphs, however positions are always essential because without it, you want be able to tell your story well or present findings.\nAnother attribute is colour. Colour in computers employ what is known as the RGB model.This model uses the colours red, green and blue, and combines them to create all the variety of colours you see on your monitor/screen. Each colour is represented with a value between 0 and 255. This is the colours intensity. For example, if all the colours are 0 (the lowest value) it will produce black. If they are all 255 (the highest value) then it will produce black. Each colour (red, green and blue) will have different values, and this will produce the colour you want. To change/establish colours in ggplot, you use the syntax color = You have to use the american spelling when using ggplot. After the “=” you can then type any colour you want. One useful feature of ggplot, is that you can make each object a different colour. For example, the data set “iris” has the width and length of a Sepal and a Petal. If you want to compare the heights of the Sepals and the Petals, you could set the color to be “Sepal.Width”. This will correlate a colour with each data point. Below is the example\n\ndata(\"iris\")\nggplot(iris, aes(Sepal.Length, Petal.Length, color = Sepal.Width)) +\n  geom_point()\n\n\n\n\n\n\n\n\nHere, I’m comparing the length of both Sepals and Petals. Some points on this graph are dark blue, almost black and others are much lighter (baby blue). The higher the length, the lighter the colour. This is shown on the legend. This feature in ggplot is useful for differentiating different data-points and making the graph more pleasing to the eye.\nIf you want to choose the colour you want on your graph, you will have to declare it within the parenthesis of your geom. Below is an example:\n\ndata(\"iris\")\nggplot(iris, aes(Sepal.Length, Petal.Length)) +\n  geom_point(color = 'green')\n\n\n\n\n\n\n\n\nHere, i have made all the points green. To make your data-points have different colours like in the other example, you will have to do that in the next part of the grammar of graphics, which is scales and transformations.\nWhy is colour a useful tool for plotting graphs? Its useful because it can look more pleasing to the eye. If your graph had no colour, it would look boring and no one would pay attention to it because its dull and not captivating. Colour can elevate a graph because the human eye is more attracted to colour. Also, colour can help you tell your story better. For example, if you wanted to present the average amount of behavior points each student has in a year group and compare them to others, using colours can help elevate your story. If the average number is low, like 8 for example, then the data point will be green. If its moderate, like 30, the data point could be orange/amber. If its high, like 40 or more, it can be shown as red. If the graph is showing older year groups are getting more behavior points than younger years, the graph can show progression from good behavior to bad by seeing green transform to red. Red is seen as a dangerous colour and red usually catches peoples attention because it shows something is bad. Many colours have associations with different things like red does, so utilising colours can enhance the story you are trying to tell.\nAnother attribute is size. Size refers to the length or area you want something on your graph to have. For example, on a scatter graph, you may want your dots to have a area of 20 pixels. For lines, size is refers to more the thickness of it. In the coding examples above, i used geom to declare how i want to map the data. These mapping options that can be manipulated with size include points and lines. The value you want size to equal is declared similarly to color. For example, like for colour, you can make it equal data. For example, I declared colour to equal Sepal.Width, which means a random colour will be assigned to each unique data-point. You can do the same for size. This will make the size of your data-point equivalent to the value of the data-points you assigned size to. Here as an example:\n\ndata(\"iris\")\nggplot(iris, aes(Sepal.Length, Petal.Length, size = Sepal.Width)) +\n  geom_point()\n\n\n\n\n\n\n\n\nIn the above graph, you can see that each data-point is different in size. Some are large, and some are smaller. This is because the bigger the width, the bigger the point will be and the smaller the width, the smaller the data-point will be. This method of adjusting size can tell a good story. For example, if you were looking at the average salary in every country, the graph can emphasise the big divide between wealth in the world. This is because you can see a real sense of scale, instead of just numbers or how much higher numbers are. You can also adjust size to your liking like this:\n\ndata(\"iris\")\nggplot(iris, aes(Sepal.Length, Petal.Length)) +\n  geom_point(size = 1)\n\n\n\n\n\n\n\n\nHere, you need to declare the size in your geom, like colour if you want to choose the size instead of ggplot choosing it for you. If you want each data-point a different size, you will need to declare that in the scales and transformations part of the grammar of graphics (See Scales and Transformations)\nSize is an essential part to being able to tell good stories from graphs because it can show change. For example, if you want to show obesity rates from the year 1925 to 2025, you can show the urgency of needing to fix it by showing data-points increasing in size as the obesity rates do. Seeing a small circle at the beginning of a graph, to a massive will captivate the viewer and show the scale of the matter. If every data-point was the same size, it wouldn’t be as captivating because you cant see the true scale, only dots or a line or other geom going up.\nThe attribute shape refers to exterior of an object. Examples are circles, squares, triangles, lines, ovals, pentagons and more. Shapes allow you to make each data-point unique so people looking at your graph can decipher different categories. To declare shapes, you use the in-built variable shape. Just like with the other aesthetics attributes, you can declare shape using data within the data-set you plotting. An example is shown below:\n\nggplot(iris, aes(Sepal.Length, Sepal.Width, shape = Species))+\n  geom_point()\n\n\n\n\n\n\n\n\nHere, I’m comparing Sepal length to its width. Notice i have declared shape within the parenthesis of aes(). I then assigned the data of “Species” to shape. This means each unique specie will be assigned a shape and that shape will display when a data-point refers to that specie or example, a setosa could be assigned as a triangle, so each time a Setosa’s sepal width and length is mentioned as a data-point, will be shown as a triangle. One thing to keep in mind however when utilising shapes for your graphs, is shapes don’t work well for continuous variables. A continuous variable is data that can be any value. For example, height and temperature are continuous variables. This is because height can be any value, its not limited to a certain range. For example, you aren’t limited to being a height of 4 foot 3 to 6 foot. Shapes are best used for categorical variables. This is data that can only be a fixed value. For example grades. In education, you are graded based a set list of possible grades. If you wanted to have a graph of every grade a student got in a school in GSCE Maths, you can use shapes because the data “grades” are fixed to grades 1 to 9, instead of infinite values.\nYou can also manually declare which shape you want on your graph. You do this by declaring it in your geom. Common practice for aesthetic attributes, is you declare your aesthetic (colour, size etc) in the aes() if you don’t mind ggplot choosing the value for you, but if you do, you declare it your geom. Below is an example of declaring shape manually:\n\nggplot(economics, aes(date, unemploy)) +\n  geom_point(shape = 8)\n\n\n\n\n\n\n\n\nHere, i have the shape value to 8. The number you set is like a value associated with a shape. For example, 0 will produce a square, 1 will produce a circle and a 2 will produce a triangle. You can experiment with different numbers and see which shape best suits your graph, and experiment with how you can modify them. To make different data-points different shapes like in the automatic version, you will need to declare that in the scales and transformations part of the grammer of graphics. Why is shape important? Its important because shapes can make it easier to decipher different categories in the data. For example, in the Iris data-set, you easily decipher different flower types because of the unique shapes each one is assigned. If your data is clustered together, using shapes may not be a good idea because it can hard to identify which shape is which. All though you can make data-points further away from others later in the grammar of graphics structure, it can be hard for people with weaker eye-sight to properly distinguish shapes if there are many close by.\n\nOverview\nOverall, we have defined what aesthetics are and the different attributes within aesthetics. I explained what each one does, and i showed my skills by showing it in a practical way, showing how it can utilised and how it looks on a graph."
  },
  {
    "objectID": "grammar_of_graphics.html#scales-and-transformations",
    "href": "grammar_of_graphics.html#scales-and-transformations",
    "title": "Explaining the Grammar of Graphics",
    "section": "Scales and transformations",
    "text": "Scales and transformations\nScales and transformations are an important part of the grammar of graphics. Scales are how we want to position and place our aesthetics. We first declare the aesthetics in aes(), then we need a way to plot them in places we want them. Without this, your IDE (integrated development environment) will decide how to plot the aesthetics for you. This is generally fine for simple graphs that aim to display uncomplex data, but as your graphics become more detailed and you wish to tell more complex stories, you will need to be able to manipulate the aesthetics yourself so the graph can tell the story you want. Transformations are changing the data. You can transform the data in a variety of ways. These are mathematical transformations, statistical transformations and multivariate transformations. The most common are mathematical and statistical transformations. Why might you want to transform data like this though? You may want to this when you have a large data-set with a large amount of numbers. Doing transformations can summarise the data and make it seem less overwhelming. Having large amounts of data is great for analysis and telling a more accurate story, but it can make it harder to visualise and make it overwhelming for someone who isn’t knowledgeable in the field.\nIn the section where i discussed aesthetic attributes, i explained how to implement them, like colour and size. When it came to being able to have more control on these attributes, i explained you can also do this in the scales and transformations section in the grammar of graphics. There are two types of scales. Measurement scales and visual scales. People often get these scales mixed-up. Measurement scales describe how your data should be measured.Some common types of measurement scales include nominal (naming, best for data like gender/country), ordinal (ordered data, best for data like ranks), interval (numeric data with no zero value, best for data like temperature) etc. Why do we need measurement scales though? We need them because some visual attributes need them. For example, line charts show change over time. So, to display this properly, we need ordinal or interval measurement scales to show this. Visual scales on the other hand are manipulations to the position, and generally how the data-points are displayed on the graphs. These include functions like linear and log.\nTo use scales within your graphic, you can use can either discrete scales or continuous scales. Discrete scales are scales that only work for data that is categorical (data that is singular in a category). For example, the number of employees in a office is discrete. This is because you cant measure it, you can only count it. Continuous scales are scales that only work for data that is continuous and has ranges. For example, age is continuous because you measure it, instead of counting it. If we go back to the section where i explained aesthetics, we can see how i explained different aesthetic attributes and how to have more control of what we can do, we need to take advantage of scales and transformations. Here, i will explain how we can know use these different types of scales (discrete scales, continuous scales) to allow for more customisation of data like colour, shape, position and size. The first one i will explain is position. To scale positions, you will need to use the code scale_x_continuous or scale_x_discrete() depending on your data type.\n\nggplot(economics, aes(date, unemploy)) +\n  geom_point() +\n  scale_y_continuous(limits = c(8000, 20000))\n\nWarning: Removed 339 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\n\nggplot(economics, aes(date, unemploy)) +\n  geom_point() \n\n\n\n\n\n\n\n\nThis is an example of a continuous scale. Dates are continuous, so they need continuous scales to be manipulated. Here, i have used the economics data-set, which is built into R studio, and i compared dates to the rate of unemployed people. Notice i used the code scale_y_continuous to declare i want to manipulate the y-axis. This is the same code as mentioned before, but instead is for y axis. In the graphs above, i used the function limits, then made that equal 8000 to 20000. What has this done? This has made it so only values ranging from 8000 to 20000 are shown on the graph. This has made the graph show less values and only show want we want. You can see on the top graph that the line of data-points has holes missing with data that is below 8000. In the original graph, we see constant dips in the data. It goes up then down multiple times. This function isn’t good for data like this. Its best used for data that is more consistent and doesn’t have huge dips constantly. We can see though hwo this function can mislead people. If you just show certain data, something could look worse or better. For example, if we had data for new COVID cases daily, we could just show when new cases were at its highest but manipulate and make it seem worse than it is currently. So, this function should be used carefully and in a way that doesn’t mislead the viewer.\nI will now show a discrete scale.\n\nggplot(mtcars, aes(mpg, cyl)) +\n  geom_point() +\n  scale_y_discrete(limits = c(\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\")) \n\n\n\n\n\n\n\n\n\nggplot(mtcars, aes(mpg, cyl)) +\n  geom_point()\n\n\n\n\n\n\n\n\nYou can see here that i changed the labels. In the top graph, i have made it show the Y axis show numbers from 1 to 8, while the bottom graph just shows 4 to 8. This can be used well to tell your story. For example, if you are looking at the GSCE grades of a class, and they all got a 3 or above, to make even the lowest grades look better, you can add more grades like 2, 1, U and so on. This can help show the teacher is good and is capable. If it just showed from 3, the grades would look worse because when people see things at the bottom of a graph, they automatically think its low and not good depending on the topic. You can also do the opposite and make some sutiutions look worse then they actually are.\nFor colour, we can use various functions within continuous and discrete scales. Which one you choose is again dependent on the data you are working with.\n\nggplot(iris, aes(Sepal.Length, Petal.Length, color = Sepal.Length)) +\n  geom_point() +\n  scale_color_continuous(low = \"blue\", high = \"pink\")\n\n\n\n\n\n\n\n\n\nggplot(iris, aes(Sepal.Length, Petal.Length, color = Sepal.Length)) +\n  geom_point() \n\n\n\n\n\n\n\n\nHere, you can see how i have manually done colours for the graph. On the top graph, instead of x or y, i used color to declare i wanted to manipulate colours. You have to declare colours in your aesthetics, make it equal what data you want then you can manually add the colours. For continuous variables, you need to set it to low, to high. This means that the lowest numbers will be whatever colour you delcare in the scales function, then as the numbers get higher, they will slowly transform into the other colour you declare. You can also notice that RStudio manually only adds one colour. This can make it hard to see an actual difference, so using scales to make this more clear, makes your graph more readable and more aesthetically pleasing to look at.\nWe will now look at how we can manipulate colours for discrete data:\n\nggplot(iris, aes(Sepal.Length, Petal.Length, color = Species)) +\n  geom_point() +\n  scale_color_manual(values = c(setosa = \"red\", versicolor = \"yellow\", virginica = \"purple\"))\n\n\n\n\n\n\n\n\n\nggplot(iris, aes(Sepal.Length, Petal.Length, color = Species)) +\n  geom_point() \n\n\n\n\n\n\n\n\nHere, i have managed to make each specie have a colour assigned to them. Species are categorical values. This is because there is no in-between or ranged values. To do this, we dont declare scale_color_discrete, instead we need to declare scale_color_manua`l. This is because scale_color_discrete is used to control colours ggplot already gives you, instead of making your colours. You can see the difference in each graph. In the top one, with scales, the colours are much more prominent, where as the bottom graph colours are lighter, rather than darker. Also, you can control which data you want people to focus on. In the top graph, i have one value assigned to yellow. This is a much lighter colour that blends in. You can use this tactic to put more focus on other parts of the graph. This could be done because the data that is in a colour that blends in could show something bad and they only want people to focus on the more positive data. Without scales, this wouldn’t be possible as ggplot would just assign a colour at random.\nShapes can have multiple functions added to them in scales. For shapes, continuous scales don’t work. This is because shapes are discrete components. You can only have single shapes, there’s no in-between values for them. Colours has ranges of in-between colours, so it can handle ranges. So, shapes can only be manipulated by discrete values. If you use continuous scales, ggplot will automatically turn them into categorical values, meaning every value will have a shape. So, here’s some discrete scales for shapes:\n\nggplot(mtcars, aes(mpg, cyl, shape = factor(cyl))) +\n  geom_point() +\n  scale_shape_manual(values = c( \"4\" = 1, \"6\" = 25, \"8\" = 9))\n\n\n\n\n\n\n\n\nHere you can see i can manually control what shapes i want. In the aesthetic section of this page, i discussed how to delcare shapes in ggplot. There, the shapes were automatic. And, if you wanted to use shapes of your choosing, every data-point had to be the shape you declared. Here though, i can manually declare each value to a shape. You do the same as in the aesthetics section where you declare shape as a variable and assign it to a number, where numbers up to 25 are shapes. This may not be optimal however if you have too many values to do (like a big-data data set). So, this is best for data sets with little categorys, so its possible to assign each one a shape. Since the shapes only go up to 25, you cant have more than 25 categories. So, shapes are best utilised for small data-sets, other wise the same shapes may repeat.\n\nggplot(mtcars, aes(mpg, cyl, shape = factor(cyl))) +\n  geom_point() +\n  scale_shape_discrete(limits = c(\"6\", \"4\", \"8\"))\n\n\n\n\n\n\n\n\n\nggplot(mtcars, aes(mpg, cyl, shape = factor(cyl))) +\n  geom_point() +\n  scale_shape_discrete(limits = c(\"8\", \"6\", \"4\"))\n\n\n\n\n\n\n\n\nAnother scale we can use is scale_shape_discrete. With this scale, we cant manually assign shapes, we can only control what ggplot gives us automatically. Here, i have shown an example. Here, ggplot has assigned three shapes. Circle, triangle and square in that order. I have managed to control which value gets what assgined shape by ggplot. You can see in the first one, i assigned the value 6 with the circle variable, value 4 with the triangle and value 8 with the square. Then with the second one i assgined the value 8 with the circle, 6 with the triangle and 4 with the square. You will need to experiment but seeing which order the shapes have been assigned and assign your values with the shapes you want. This gives us more control but scale_shape_manual is best for choosing shapes, rather then working with what you have. You won’t always need to choose your shapes, and ggplots choice of shape usually gets the job done.\nFor size, we can go back to using both discrete and continuous scales. Size is a measurement by nature. It was invented for measurement. So, we aren’t limited to discrete values because of how size is valued. An example of a dicrete value is below:\n\nggplot(iris, aes(Petal.Length, Petal.Width, size = Species)) +\n  geom_point() +\n  scale_size_discrete(range = c(1, 3))\n\nWarning: Using size for a discrete variable is not advised.\n\n\n\n\n\n\n\n\n\nHere, i have declared the size to be Species, meaning each unique specie will be shown at a specific size. Here, i have declared the scales scale_size_discrete and within the parenthises, i declared a range of 1 to 3. This means that the size will range from 1 to 3. Since there are three species, i choose to have a three number range. This is because i want each specie to look similar in size but still be distinguishable from far away. However, if from 1 to 8, the Versicolor and Virginica data-points would be much bigger and the setosa data-points would be missed because the bigger points are much more prominent. I will now show a continuous scale:\n\nggplot(economics, aes(date, unemploy, size = unemploy)) +\n  geom_point() +\n  scale_size_continuous(trans = \"log10\")\n\n\n\n\n\n\n\n\nYou can see on this scale i have used the mathematical function log10. Log10 will essentially make smaller values more visible. This works best for data-sets with high ranges like from 1 - 1000. This is because for smaller data-sets, the smaller data can be seen more visibly, so adding log10 won’t add much extra benefit.\nScales are very important for making your graph your own. In the aesthetics section, i previously discussed how add poisitons, sizes, shapes and colours. They were very limiting and when you could customise, it didn’t give you much freedom in terms how specifics. For example, excel has graphs but they are very set in stone in terms of how they look like. The graph isn’t your own and looks like a standard graph. Having scales can help make your graph your own and make things how you want, not how a computer wants to. They also look more pleasing to the eye, because there is something new to look at as you go across the graph, so its better for presentations and getting peoples attention.\nFor transformations, i discussed earlier the different types of transformations you can do on your data. These were mathematical and statistical transformations. Some mathematical transformations include log(x), exp(x), sin(x), cos(x), tan(x), acos(x) etc. Mathematical transformations will influence the data by applying mathematical principles to them. This will change the way raw data is shown without affecting its structure. Statistical transformations include mean(x), median(x), mode(x), sort(x), residual(x), rank(x) etc. Statistical transformations are for summarising data and revealing potential trends. Here’s some mathematical transformations in real code:\n\nggplot(economics, aes(date, unemploy)) +\n  geom_point() \n\n\n\n\n\n\n\n\n\nggplot(economics, aes(date, log10(unemploy))) +\n  geom_point() \n\n\n\n\n\n\n\n\nHere, i have two graphs. One doesn’t have the log10 function, the other one does. The first difference is the values. On the first graph, the values of unemploy are shown as 4000 to over 12000. In the second graph however, the numbers are changed to 3.4 to 4.2. This is because log10 compresses larger values and expands the smaller values. This means that data on the lower end can be seen more clearly. You see more data-points on graph 1 then you can on graph 2. If the difference in data is big, like 4000 to 12000, the larger values will dominate the graph, meaning the smaller values are undermined and look messier. So, by compressing the values, it will allow for the smaller values to be more spread out and can reveal patterns once otherwise unseen. If you are plotting graphs to analyse them and make decisions, your decision could be much different from not using log10 to using it. This is because you may not seen patterns at the bottom without it, and this can lead to a bad decision, and you would’ve thought of a better one had you seen the trends that were hidden.\nAnother mathematical transformation is sin(). Heres another comparision between the difference of a graph with sin(), and another without it.\n\nggplot(mtcars, aes(cyl, disp)) +\n  geom_point()\n\n\n\n\n\n\n\n\n\nggplot(mtcars, aes(cyl, sin(disp))) +\n  geom_point()\n\n\n\n\n\n\n\n\nHere i have used the sin() mathematical transformation. Again, this is declared before data is plotted, and sin has the value of disp. This means that the graph will display the values of each data value in the row disp in its sine value. These are in-between -1 and 1. This is a similar mathematical transformation to log10, which was just discussed above. Comparing the two graphs above, they both look very different. The data has seemed to flip between each graph. For example, the data-points above 8 on the cyl axis are on the bottom in the graph with sin, where as they are on the top for the graph without sin.Sin is best used to transform data that repeats patterns over and over like days of the week and sound waves. Sin is a relatively rare mathematical function in graphs because its used for a niche topic, and doesn’t make too much sense with non-repeating data. So therefore, the transformation sin won’t make much sense on this graph, however it does get the message across of rotations and patterns being good for the sin function.\nFor statistical transformations, there are a variety of methods. These are bins, summaries, regions, smooth and links. All of these will help elevate your graph by creating new data to help with condensing data properly. Each statistical transformation will only work for select geometries, so it wont work for some. This is something to keep in mind if you have a specific geometric you want to use to tell your story.\nBins are groups of data that are within a given range. For example, if you have data on the average household size for every country, you may have values ranging from 3 to 9. If you had 5 bins, your bins will have the ranges 3 - 4, 4 - 5, 5 - 6, 6 - 7 and 7 - 8. Each bin will have an equal range. The graph will then show the number of data-points that are within that range. This can help with summarising data faster and you could notice trends you wouldn’t have seen otherwise. This is an example in practice:\n\nggplot(iris, aes(Sepal.Length)) +\n  geom_histogram(bins = 8)\n\n\n\n\n\n\n\n\nHere, bins are set to 8, which means the bars are relatively big. This manipulation can be useful if you need to find out this data but it will take too long to manually do it. It essentially automates it for you. You will need more bins if your data has much higher ranges and/or is larger.\nNow we will look at summary. This has already been discussed in the transformations section on this page. We have seen how we can use mean to help summarise and shrink down large data-sets. We will now look the median and sum to show this. This is how we can use median in practise:\n\nggplot(iris, aes(Sepal.Length, Sepal.Width)) +\n  stat_summary(fun = median, geom = \"point\")\n\n\n\n\n\n\n\n\n\nggplot(iris, aes(Sepal.Length, Sepal.Width)) +\n  geom_point()\n\n\n\n\n\n\n\n\nHere, you can see the difference between the two graphs.The top graph, which uses the function stat_summary, which calls the summary method, and within it, you do your statistics. You can notice that the bottom graph is quite clustered and it looks like there is a lot of data. In the top graph however, its much less clustered and the data looks smaller. The function median finds the middle number of a list of data. Lets say you have the sequence 2, 3, 4, 5, 6, 7, 8. The median will be 5. This is because its in the middle of the sequence. If the number of values is odd, there will be one median, if its even however, you average the two numbers in the middle by adding them and dividing them by 2. What ggplot has done for the top graph is get all sepal lengths. They group all values that are the same value, and find the median sepal width. For example, if there were 3 species with the same sepal length, they would get their sepal widths, put them in order of lowest to highest, then find the median. This means there is only one data-point for each sepal length value, instead of multiple. This makes it look way less clustered and makes it easier to read. The bottom graph is much better for in-depth analysis. This is because there is more data to work with and you could notice trends you otherwise wouldn’t. The top graph is better for presentations as its easier to understand and doesn’t look overwhelming. The next summary function is sum. The sum is the addition of all values within a data frame. Here is the sum function used in practice:\n\nggplot(mtcars, aes(cyl, mpg)) +\n  stat_summary(fun = sum, geom = \"point\")\n\n\n\n\n\n\n\n\n\nggplot(mtcars, aes(cyl, mpg)) +\n  geom_point()\n\n\n\n\n\n\n\n\nHere, again, you can see the big difference between each graph.The bottom one has lots of data-points and looks congested, however, the top graph is has very minimal data-points. This is because, you can see that only three cyl are used on the graph (4, 6, 8). Each one of them numbers can be seen as a data frame. Ggplot has added all the numbers in those data points together and displayed it on the graph. You can also see on the first graph, the only values on the y axis are in the hundreds, where as the bottom graph only has double digits. This kind of function could be used for almost any businesses. For example, cafes could use this to display to investors or manufacturers, that there business is worth working with. They could make a graph with all the months and have the sum of all the money made in that month and show it. Overall, this function summarises data well.\nThe next statistical method is region. Region makes a geometry out of interval data. Geometries are built on data, but the data wont have equal intervals between data (for example, a data frame may have data as 2, 5, 6, 8. The intervals aren’t consistent nor the same.) So, regions will create those equal intervals and produce data-points to show the data in each interval. For example, if you have data with three intervals like 2 - 5, 5 - 8 and 8 - 11, then your graph will produce a geometry to show the data in each interval. This is useful when summarising data and presenting it, instead of doing a full-depth analysis. I will discuss two functions that can do this. These will be standard deviation and standard error.\nThe standard deviation is how far values in a data-set are from the mean. This is great to show how data can deceive people. You can use means to tell a story and use it to make a big decision. However, if the standard deviation is high, that means the data could be off and you make a bad decision because of it. Here is standard deviation in graphs used in practice:\n\nggplot(ToothGrowth, aes(len, dose)) +\n  stat_summary(fun = sd, geom = \"point\")\n\nWarning: Removed 30 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\n\nggplot(ToothGrowth, aes(len, dose)) +\n  geom_point()\n\n\n\n\n\n\n\n\nThis is the same principle as the statistical function median. As you can see, the top graph is much less clustered where was the bottom one has much more data-points. It has summarised the data by using standard deviations. Again, the top graph is best for general viewing and presentations, as it makes the graphs look less complicated and overwhelming. The bottom graph is better however for analysis as it contains more data to work with, meaning you could notice trends you otherwise wouldn’t have.\nStandard error is when you find out the standard deviation between samples of data. For example, if you had data on how many people are in a shopping centre on a weekday compared to weekend, your data samples will vary. You could do the inital test in winter, where more people will likely be there because its colder, so people are less likely to be outside doing things. If you did it in the summer, less people may be there because its warmer, so people are more likely to be outside instead of indoors. So because of this, standard error was made so it can measure the difference between data samples means. Heres standard error in practise:\n\nggplot(mtcars, aes(mpg, hp)) +\n  stat_summary(fun.data = mean_se, geom = \"errorbar\") +\n  stat_summary(fun = mean, geom = \"point\")\n\n\n\n\n\n\n\n\n\nggplot(mtcars, aes(mpg, hp)) +\n  geom_point()\n\n\n\n\n\n\n\n\nBoth graphs are very similar in terms of the amount of data points. However, the first graph has an error bar to show the standard error. What ggplot has done in this graph is take each unique mpg and turns them into unique groups. In this particular data-set, there are some mpgs that are singular, while some mpg values appear more than once. These duplicate values will become groups and ggplot will work out its standard error. You will notice some data-points have bars. This is the standard deviation. The ones without it are ones that have a unique mpg value, it doesn’t appear again in the whole data-set. You can see that the SE (standard error) is relatively low. This means the mean is similar to other samples of data. Using SE can show that the data collected is accurate with little errors, but it can also show bad data collection methods or human error, depending on how long the bars are. Having SE shown on a graph can help with presenting samples without having multiple graphs, and can show how different situations can produce different data. This could be used for shops, where they measure foot traffic but show SE as it could have been a slower week then normal or was during summer holidays, where shops are much busier because of schools closing. Having SE can also make sure graphs are more authentic, as some graphs can be misleading and only show data that is way off the average from other samples.\nThe next statistical method is smooth. When you have data, its often not ideal for plotting graphs or analysing it. Trends/patterns are hard to see in raw data (data before anything is manipulated, its original form) and seeing it this way can lead to bad decision making or not truly representing what the data is showing. The smooth function estimates trends/patterns from the raw data to make it more readable. To use smooth in practice, we look at the functions linear and density. Heres how linear can be used in practice:\n\nggplot(iris, aes(Sepal.Length, Petal.Length)) +\n  geom_point() +\n  stat_smooth(method = \"lm\", geom = \"line\", colour = \"blue\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nYou can see that there is a line going through the graph. This line has been produced by ggplot, by estimating a trend using existing data-points. It takes the first data-point on the left of the graph and then gets the first data-point on the right. Using this data and the data in-between these data-points it draws something called a line of best fit. It shows an estimation of change over time. This function is best for when you want to show the overall picture. The line simplifies the graph. Without it, it may look confusing as there are multiple data-points for each sepal length value, which may show inconsistent data that doesnt tell you much. But, the line shows consistent growth in petal length as sepal length increases.\nThe next smooth function is density. Density what parts of your data are the most dense. This means how close they are together. Here’s density in practice:\n\nggplot(iris, aes(Sepal.Length, Petal.Length)) +\n  geom_point() +\n  stat_density_2d()\n\n\n\n\n\n\n\n\n\nggplot(iris, aes(Sepal.Length, Petal.Length)) +\n  geom_point()\n\n\n\n\n\n\n\n\nThe first difference between both of these graphs is the blue circles on the top graph. This shows the density of your data. The blue lines are showing the distance between data-points. You can see that some parts are like Russian dolls, where there is a circle within a bigger circle then other parts are much more open with nothing in-between. This can help you with showing trends. For example, if you looked at the temperature every day for a year, you could use density as a way to show how when a new season starts, the weather is very similar and how much it changes between seasons. So, nothing has been done to the data, rather a new way to show change in the data. With the new density lines, you may be able to spot which sections are new species. For example, the first dense part is setosa and the next one is versicolor.\nThe final statistical method is link. Link is a very useful function. It takes your data and predicts its values as a projector. This can be used for probabilites or counts.\n\nggplot(ToothGrowth, aes(len, as.numeric(supp == \"OJ\"))) +\n  geom_point() +\n  stat_smooth(method = \"glm\", family = binomial(link = \"logit\"))\n\nWarning in stat_smooth(method = \"glm\", family = binomial(link = \"logit\")):\nIgnoring unknown parameters: `family`\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\nggplot(ToothGrowth, aes(len, supp)) +\n  geom_point()\n\n\n\n\n\n\n\n\nHere, we have used logistic regression, which measures probability. This means that it will take a tooth length, and show how likely it is to be one supplement rather than the other. So, ggplot will take each tooth length, and then predict whether its an OJ supplement or VC supplement. It does this by using a scale of 0 to 1. 1 being its very confident its OJ and 0 being its definitely VC. This can be used to show predictions vs actual data. What i have done, is i have made the supplements (OJ, VC) as binary. Meaning 0 is VC and 1 is OJ. The dots show the actual data collected for the ToothGrowth data-set. The blue line is the predictions for each tooth-length. You can see that as the tooth length increased, so did the probability of it being OJ as the supplement chosen. This was sort of the case as more data-points appeared as the tooth length did.\nThe next link function i will show is poisson regression. This is for predicting counts:\n\nggplot(economics, aes(date, unemploy)) +\n  geom_point() +\n  stat_smooth(method = \"glm\", family = poisson(link = \"log\"))\n\nWarning in stat_smooth(method = \"glm\", family = poisson(link = \"log\")):\nIgnoring unknown parameters: `family`\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\nggplot(economics, aes(date, unemploy)) +\n  geom_point() \n\n\n\n\n\n\n\n\nWe will now use poisson regression, which will predict counts. This is similar to logit regression but for counts. It will take a date, and predict how many unemployed people there will be. Instead of using probability, it will predict a real number, instead of a probability value. The blue line represents what ggplot predict the number of unemployed people will be on different dates. It got it relatively accurately. The real data goes up then down then up again, while the prediction is it goes up continuously every year.\n\nOverview\nOverall, scales and transformations are very important in the grammar and graphics and producing complex graphs in general. Scales allow you to manipulate how your data is placed. This will let you tell the story you want, instead of letting ggplot just do it for you and have no control of it. Transformations can help change your data, which allows you to make graphs easier to read and make data easier to work with and help tell the story you want."
  },
  {
    "objectID": "grammar_of_graphics.html#geometries-and-statistical-elements",
    "href": "grammar_of_graphics.html#geometries-and-statistical-elements",
    "title": "Explaining the Grammar of Graphics",
    "section": "Geometries and statistical elements",
    "text": "Geometries and statistical elements\nGeometries are how we want to present the data. This can include a point, barchart, histogram and more. Choosing the right geometric is important for the story you want to tell with your graph. Different geometric’s will present the data differently, so choosing the wrong one can cause the viewer to have a view you didn’t want. Lets explore this by using the same data-set and data for multiple graphs but change the geometry each time.\n\nggplot(mtcars, aes(mpg, disp, color = disp)) +\n  geom_point()\n\n\n\n\n\n\n\n\nHere’s the first graph. I have used the mtcars data-set with the x-axis being mpg and the y axis being the disp. I have also chosen the geometry point. This has essentially made a data-point for each mpg and placed it in the place that is opposite its disp on the y-axis. This geometric allows you to show all the data individually, meaning you can find data in the data-set and easily find it on the graph unless its condensed.\n\nggplot(mtcars, aes(mpg, disp, color = disp)) +\n  geom_line()\n\n\n\n\n\n\n\n\nThis graph uses the same data-set, same x and y axis but the difference is the geometric. I used a line instead of points. Here, there is a continuous line that goes through the graph and goes up and down according to what each mpg has for disp in the data-set.\nSo, how has the geometric affected how you can view the graph? For points, you can see each individual data-point and points make clusters easier to notice. This is because our eyes catch bigger things first. A line wont be able to do that because the line thickness/size will stay the same, unless you manipulate it with scales, but it still won’t have the same effect. Lines however are better for noticing overall trends. This is because you can see big spikes, consistency and huge dips. Since you don’t have to mentally connect the dots like with lines, this makes them much more transparent. Also visually, the first graph less denser and messier. Where as the second graph looks more organised and less dense.\nThe biggest difference is that points are more focused on specific data and lines are more focused on trends and seeing the bigger picture. For example, if you want to see how the 10 countries with the highest amount of doctors per 10,000 people compare in numbers, you may want to use points. This is because you can focus on each country. For example, the countries with the highest doctors per 10,000 people may be Monaco, Germany, Luxembourg, Spain, Norway, Finland, Denmark, Netherlands, Belgium and Japan.Your goal isn’t to see trends, it’s to see each individual country and how they compare to the next. Where as with a line, its more focused on trends, rather than comparisons. you may use a line to see house price increase. If you want to see how house prices have changed over the years, you may use a line. This is because you aren’t focused on each specific year, you are more focused on seeing a general timeline and see how prices have increased or dropped in some senraios. For example, on the x-axis, you may have years shown as every 10 years (1900, 1910, 1920, 1930, 1940 etc). This suits a line much better as there’s no specific year you want, you just want to see how it changed between one decade to the next. Overall, you want to use points for data you want to analyse with more depth and specifics, and use a line just to show trends and for less complicated analysis.\nNow lets compare bar charts and histograms. Below are two graphs, one will be a barchart, the next one will be a histogram.\n\nggplot(ChickWeight, aes(Diet)) +\n  geom_bar()\n\n\n\n\n\n\n\n\n\nggplot(iris, aes(Sepal.Length)) +\n  geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value `binwidth`.\n\n\n\n\n\n\n\n\n\nBar charts and histograms are similar, but different. Bar charts have bars that are separated, where as histogram bars are all joined together. Histograms are counts of numeric data but bar charts only compare counts of categories. Essentially, histograms are for numerical data, and bar charts are for categorical data. Each graph will make you look at the data differently. Their differences are the same as the differences between lines and points. Bar charts are better for individuality. This is because each bar is separated, meaning you can easily look at each unique data-point. For histograms however, its continuous like lines, meaning you can better see trends and is better for general viewing rather than for a in-depth analysis.\nStatistical elements are mew components added to a graph from transformed data. We have previously seen this in practice:\n\nggplot(iris, aes(Sepal.Length, Petal.Length)) +\n  geom_point() +\n  stat_smooth(method = \"lm\", geom = \"line\", colour = \"blue\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nHere’s a graph from earlier. We have geom_point, which is showing the raw data. We then applied a transformation of linear to the data. This is the statistical transformation. We have changed the data before displaying it. The statistical element is then the line. This is our transformed data being shown. This is the statistical element, the result of our transformation. For example, if we want to edit a photo using Photoshop, the original photo is our raw data. The things you do to the photo in Photoshop, like adding lighting, cropping things etc, is the transformation. The final image is then statistical element. It shows the added components you did in Photoshop. Other examples of where we did this are:\n\nggplot(iris, aes(Sepal.Length, Petal.Length)) +\n  geom_point() +\n  stat_density_2d()\n\n\n\n\n\n\n\n\nThe statistical element is the lines we see are the results of calculating the density of our data-points, and the actual calculating of the density of the data-points is the transformation.\n\nggplot(economics, aes(date, unemploy)) +\n  geom_point() +\n  stat_smooth(method = \"glm\", family = poisson(link = \"log\"))\n\nWarning in stat_smooth(method = \"glm\", family = poisson(link = \"log\")):\nIgnoring unknown parameters: `family`\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nThe transformation is “glm” and poisson. The statistical element is the line now produced of the predictions of the number of unemployed people across the years.\nStatistical elements aren’t always manually declared. They are sometimes set-in-stone by certain transformations. This is the case for the two graphs above. We do however have to for some transformations, like the first graph i showed. We are limited to some elements for some transformations, as some wouldn’t physically work in that context.\nStatistical elements isn’t something you need to think about too hard, because you don’t have much control on what elements are shown for your transformations. With normal geometric’s , you have all the options available to you at anytime, but for transformations you are limited because of the transformations nature.\n\nOverview\nOverall, geometries and statistical elements are essential for how data is shown. Geometries are how data is shown using shapes like points, lines, bar charts and box plots. I discussed how each one is unique and how choosing a different geometric can influence how the data is shown and explained how you might use each one with examples. I then looked at statistical elements, showing how they plot the transformations, rather than raw data."
  },
  {
    "objectID": "grammar_of_graphics.html#coordinates",
    "href": "grammar_of_graphics.html#coordinates",
    "title": "Explaining the Grammar of Graphics",
    "section": "Coordinates",
    "text": "Coordinates\nCoordinates in the grammar of graphics are how we position the whole plot. In scales and transformations, we are just manipulating the aesthetics, like colour, shapes and sizes, however with coordinates, we are controlling how the whole graph is placed. Coordinates allow us to present data however we want, to tell the story we want to tell. Manipulating coordinates can lead to misleading graphs, however if its used correctly and ethically, we can use it to change peoples minds, without twisting the original data. The most common coordinates are Cartesian, Polar and fixed. Cartesian coordinates refer to the x and y coordinates. This means you can manipulate the positions of the x and y coordinates. These will be in every graph, so you can use cartesian coordinates in every graph, it’s not limited to some specific circumstances. Here’s this in practice:\n\nggplot(iris, aes(Sepal.Length, Sepal.Width)) +\n  geom_point() +\n  coord_cartesian(xlim = c(4, 7), ylim =c(3, 5))\n\n\n\n\n\n\n\n\nThink of the graph being a painting and we need to place it in a frame. How we place it in the frame is the above code. We can place the frame anywhere we want on the painting. We chose where we want it in the xlim() function. We are saying we only want to see values between 4 and 7. It will exclude anything outside of this range. This is very similar to previous code we looked at:\n\nggplot(economics, aes(date, unemploy)) +\n  geom_point() +\n  scale_y_continuous(limits = c(8000, 20000))\n\nWarning: Removed 339 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\nHere, we have done a similar thing. We have limited what data we want to see. However, there is a big difference. If you do this with coord_cartesian(), then the data you have excluded is still there. Ggplot has just zoomed in on that section like a camera. For example, if you took a photo of an enitre mountain, then when you got home you wanted to see the peak more clearly, you can zoom in to just show the peak. The rest of the picture is still there, you have just limited what you want to see. This is the same concept. If you use scale_y_continuous instead, the data is actually deleted instead of just zooming in. You can see in the graph above some data points are missing, however in the first graph, you can see the top half of some data-points, showing data hasn’t been deleted. You only use the above example when you know some data is invalid and for overall data cleansing. You should use the first example most of the time because unless your cleaning data, you may mislead people. This shows how different parts of the grammar of graphics can do similar things, but have important distinctions that data visualisers should know to not mislead viewers.\nPolar cooridnates will make data-points according to how far it is from a central point rather than along the x and y axis. A great example of a polar coordinate is a pie chart:\n\nggplot(mpg, aes(1, fill = class)) +\n  geom_bar() +\n  coord_polar(theta = \"y\")\n\n\n\n\n\n\n\n\nHere, we have a pie chart for the number of certain car types in a data-set. A polar cooridnate system measures values by seeing how far it is from a central point, known as radius r, and direction which is known was angle 0. For pie charts specifically, ggplot will work out what percentage of the total values a certain value takes up, turn it into a decimal and times it by 360 degrees, which is the angle of a circle. for example, if you had data on the year groups of students on a work experience programme, and 50% of students were in year 12, you would do 0.50 X 360 to find out what degree that section should be in the circle on the pie chart, which is 180. This means ggplot will make this section 180 degrees. Polar charts can become misleading if the design choice is poor. For example, for pie charts, a small section on the chart will leave the impression that that value is irrelevant or small in comparison to the rest of the data, but it could be a huge value and is relatively significant. So, choosing a polar coordinate system can either enhance your graph, making it make more sense or more readable, but also ruin it by adding deception or making it misleading.\nA fixed coordinate is a coordinate that has a fixed aspect ratio. This means that once you declare an aspect ratio, ggplot will make sure that it follows this aspect ratio and never change it. This means that no matter what is added to the graph,, it will keep that ratio, never distorting it. This can be achieved by using coord_fixed. Here’s fixed coordinates in practice:\n\nggplot(economics, aes(date, pce)) +\n  geom_polygon() +\n  coord_fixed(ratio = 2)\n\n\n\n\n\n\n\n\n\nggplot(economics, aes(date, pce)) +\n  geom_polygon() +\n  coord_fixed(ratio = 2)\n\n\n\n\n\n\n\n\n\nggplot(economics, aes(date, pce)) +\n  geom_polygon() \n\n\n\n\n\n\n\n\n\nggplot(economics, aes(date, pce)) +\n  geom_polygon()\n\n\n\n\n\n\n\n\nHere, i have set the radio to be 2. What ggplot has done is its scaled the y axis by 2. This means the x axis has been condensed so the y axis is 2 times bigger then the x axis. I have four graphs. Two are to show the difference between the graphs with or without the coord_fixed function, and the other two are to show its effects clearer. You can see that the graph with coord_fixed is much smaller than the one without it. I then made another graph to show what they look like when the graph is resized to be bigger. You can see the graph with the coord_fixed function has the same dimensions, it just became a much smaller overall graph while keeping its aspect ratio. Then, for the graph without the coord_fixed function, its aspect ratio got distorted and the graph stretches. This can now become misleading. The stretched graph looks like PCE increased slowly over each decade. However, the non-stretched graph looks like PCE increased much quicker over the decades. Depending on your goals or what the data is actually showing, this can become misleading. If PCE actually had drastically increased over the decades, the first graph is much better because it accurately shows this. However, the second graph doesn’t, because it shows a much more gradual rising, because it got lengthened so much. If the data is more accurate when shown this way, then coordinates aren’t needed. However, visualisers need to be careful that they wont mislead people or use it for unethical purposes. If you don’t want to change the ratio of your graph, but you don’t want it changing when different components are added, you can set the ratio to be 1. This will keep the default ratio, which is 1:1, but you still get the benefits the ratio never changing.\nAnother concept of coordinates is isometrics. Fixed coordinates and isometrics are used together. As discussed previously, fixed coordinates preserve the ratio of the graph, meaning geomtries aren’t distorted. Isometrics are transformations to geometries. Fixed coordinates are needed so the isometric transformations don’t look distorted. There are three types of isometric transformations. These are translations, rotations and reflections. Translation is moving an object either horizontally or vertically without changing its properties. Rotations is rotating an object around its central point without changing its properties. Reflection is inverting an object either horizontally or vertically. (Leland Wilkinson 2005). These transformations can stretch the graph in a way that ggplot is forced to stretch an axis so it can fit the new object. This can distort the graph and as seen in the examples above, you can use fixed coordinates so the graphs aspect ratio is the same, while still being able to have the benefits of the transformations. It could be good practice to apply fixed coordinates when doing any transformation to prevent the risk of a misleading graph, even if you don’t see much difference.\n\nOverview\nCoordinates are used for position of objects and data. They can help shape the data in ways that you want, to enhance your story, and show more light onto certain data. Coordinates should be used carefully as they can lead to mis-information and/or misinterpretation."
  },
  {
    "objectID": "grammar_of_graphics.html#guides-and-facets",
    "href": "grammar_of_graphics.html#guides-and-facets",
    "title": "Explaining the Grammar of Graphics",
    "section": "Guides and facets",
    "text": "Guides and facets\nGuides help with explaining your graph. If you saw a graph with no titles, lots of colored data-points, then you would be confused on what you are looking at and you wont understand what its trying to prove. Guides can be used to show what different parts of the graph mean/show. Without guides, graphs will be pointless, doesn’t matter how well they tell their story or how aesthetic it looks. One common example of a guide is legends. Legends are usually seen outside of the actual graph with little boxes with colors/symbols with names next to them. For example, a legend could say:\n\nBlue = Primary school\nPurple = Secondary school\nRed = College\nGreen = University\n\nA graph could show the average grade of a student in primary school, secondary school, college and university. This could be shown with colours to differentiate them. The viewer wont know what the colours show, so this legend would be useful so people know what colour is what.\nTo make guides, you will need to delcare guides() or you can do this in labs() or theme(). What is the difference between these? Guides will be for controlling your mappings, like legends. For labs, its the name of your properties. For example, this is where you will name the x and y axis. Ggplot just names them how they are shown in the data-set. You can also provide a title for the whole graph and name of the legend. Theme is everything else that has nothing to do with the actual data on the graph. This could include text size I will now go through each one and explain what you can do with them: First one is guides. For guides you could do:\n\nggplot(iris, aes(Sepal.Length, Sepal.Width, colour = Species)) +\n  geom_point() +\n  guides(colour = guide_legend(title = \"The Legend\"))\n\n\n\n\n\n\n\n\n\nggplot(iris, aes(Sepal.Length, Sepal.Width, colour = Species)) +\n  geom_point() \n\n\n\n\n\n\n\n\nYou can see that ggplot automatically applies legends, but might not do it in the way you want. For example, ggplot just names the legend the name of the data you made colour equal, so you can customise it as done above. This doesn’t affect the data, it just effects the labels. This only needs doing is the name of the legend is an abbreviation, like cyl in the mtcars data-set. Viewers may not know what it stands for, so using full words will help viewers understand. Another things you can do to legends is change their order:\n\nggplot(iris, aes(Sepal.Length, Sepal.Width, colour = Species)) +\n  geom_point() +\n  guides(colour = guide_legend(reverse = TRUE))\n\n\n\n\n\n\n\n\nHere, i have managed to reverse the order of the legend. The original order was setosa, versicolor then virginica. You can also manually change the order in any way you want in scales.\n\nggplot(iris, aes(Sepal.Length, Sepal.Width, colour = Species)) +\n  geom_point() +\n  scale_colour_discrete(breaks = c(\"virginica\", \"setosa\", \"versicolor\"))\n\n\n\n\n\n\n\n\nOrder doesn’t matter too much for legends, however it can for certain circumtances. For example, you may have different colour points that are spread out in categories, like red is all in one section, then yellow in the next. Having your legend be in that order, can help with navigation because you just need to look one colour down, instead of searching through it each time.\nNext one is labs. For labs, you could declare:\n\nggplot(ToothGrowth, aes(len, supp)) +\n  geom_point() +\n  labs(title = \"Tooth Growth Graph\", x = \"Tooth Length\", y = \"Supplement\")\n\n\n\n\n\n\n\n\n\nggplot(ToothGrowth, aes(len, supp)) +\n  geom_point()\n\n\n\n\n\n\n\n\nHere, i have changed the labels on the graph. I added a title, and renamed the x and y axes. You can see in the non-modified graph, there is no title and the names of the x and y axes were len and supp. These are abbreviations, and this can look lazy to some viewers or can make the graph confusing. Since there is no title, viewers don’t know the context, and since the x and y axes are labeled with abbreviations, viewers can struggle with deciphering the graph. With the changes however, the title gives context, and the x and y axes are labelled with full words, not abbreviations. You can see how this has enhanced the graph and made it look more professional.\nThe final guide function is theme. You can declare the following:\n\nggplot(iris, aes(Sepal.Length, Sepal.Width, colour = Species)) +\n  geom_point() +\n  labs(title = \"Sepal length vs width\") +\n  theme(legend.position = \"bottom\", plot.title = element_text(size = 25))\n\n\n\n\n\n\n\n\n\nggplot(iris, aes(Sepal.Length, Sepal.Width, colour = Species)) +\n  geom_point() +\n  labs(title = \"Sepal length vs width\")\n\n\n\n\n\n\n\n\nYou can see how i have manged to change positions and size. I have changed the size of the graph title so its more prominent, and i made the legend be at the bottom. The position of the legend is the preference of the viewer and how they like to look at them. A bigger title can catch the attention of the viewer first, because humans are drawn towards to bigger things first rather than small. So, this means the first thing people see is the context of the graph and then the graph, then the legend. The downside of a legend on the bottom, is it can be easy to miss, so viewers can become confused quickly.\nWhile guides overall don’t effect the data or how the graph its self is shown, they are essential for viewers to be able to navigate the graph, and know what each part means within the legend, what each axes shows and what the graph is actually showing with the title.\nFacets are multiple graphs in one. Facets are used for comparisons. Each graph will show subsets of the data you provide, but with the same axes. There are different types of facets. Ones called grid, and the other one is wrap. We will first look at grid facets:\nYou will use a grid facet when you want to use two variables. It will create the graphs with one variable for rows and other for columns. Here it is in practice:\n\nggplot(ToothGrowth, aes(len, dose)) +\n  geom_point() +\n  facet_grid(supp ~ dose)\n\n\n\n\n\n\n\n\nHere, i have used the tooth growth data-set, and im comaring length with dose. I have then used points for my geometric and then i declared a facet grid function. I have then used the supp variable and dose variable to facet. The first variable you declare will be shown in rows, and the second will be as columns. So, ggplot has taken all the supplement values and placed them as rows. Then, ggplot has taken all the dose values and placed them in rows. Now, the graph will show the teeth length for each dose value for each supplement. This can make comparisons much easier because data points can easily be hidden behind others if you didn’t use facets. Facet grids are best for more complex data that has a lot of subset data. Facets in general are good for presentations. This is because ggplot labels the name of the variables and it shows each unique data-point.\nWe will now look at facet_wrap():\n\nggplot(ToothGrowth, aes(len, dose)) +\n  geom_point() +\n  facet_wrap(~supp)\n\n\n\n\n\n\n\n\nFacet wrap should be used for one variable. Here, i have used the tooth growth data and declared the x and y axes to be length and dose. I set the “point” geometric and then used facet_wrap(). I then used the “~” symbol then declared the variable supp. Ggplot has subsetted all the supplements in the data-set, and just displays the data for that supplement. We can now just see the length of teeth to the dose for OJ and VC. Before, we had to see both of them on one graph. This can become confusing and overwhelming when trying to analyse just one supplement, so using facets is great for comparison. We can now see clearly the data is relatively similar. Lower doses are associated with lower teeth length, and higher doses are associated with longer teeth. We also now don’t have to worry about data overlapping with each other, we can see every data-point individually. So this means we can see patterns/similarities/differences much easier.\n\nOverview\nGuides are how we explain our graph. We do this with labeling the x and y axes, the title of the graph and controlling the legend. Facets are multiple graphs in-one, where variables are subsetted to avoid dense graphs taht block data-points and make the graph look overwhelming."
  },
  {
    "objectID": "grammar_of_graphics.html#how-all-grammar-of-graphic-principles-combined-work",
    "href": "grammar_of_graphics.html#how-all-grammar-of-graphic-principles-combined-work",
    "title": "Explaining the Grammar of Graphics",
    "section": "How all grammar of graphic principles combined work",
    "text": "How all grammar of graphic principles combined work\nNow we have discussed all the grammar of graphics principles and i have explained what they mean. But how do they all fit together? Here’s a graph with all grammar of graphic principles applied and how they work together:\n\nggplot(iris, aes(Sepal.Length, Sepal.Width, colour = Species)) +\n  geom_point() +\n  scale_colour_manual(values = c(setosa = \"red\", versicolor = \"purple\", virginica = \"yellow\")) +\n  stat_summary(fun = median, geom = \"line\") +\n  coord_fixed(ratio = 1) +\n  guides(colour = guide_legend(title = \"Species\")) +\n  labs(title = \"Sepal Length vs Sepal Width\", x = \"Sepal length\", y = \"Sepal width\") +\n  theme(plot.title = element_text(size = 20)) +\n  facet_wrap(~Species)\n\n\n\n\n\n\n\n\nFirst, we define what data set we are using. We then declare aesthetics. This is what are x and y axes will be, and what we want to appear on the graph like colour. I have chosen to use Sepal.Length and Sepal.Width as my x and y axes then declared colour to be species, meaning every unqiue specie will be a different colour. I then declared my geometric to display my raw point, which are points. This means every data-value will be pin-pointed with a dot. I then used scales to manually include what colour i want each specie to be. I then combined this with a transformation, to show the median of sepal width for each sepal length, and used a statistical element to show this (used a line in this case). I then added coordinates, which was fixed coordinate so my graph stays consistent in terms of aspect ratio. Then i added guides to rename my legend, make a title for my graph and named the x and y axes. Then, i adjusted the size of my plot title. I then used a facet to subset species, so each specie has its own graph for comparing sepal length vs sepal width. Each element has added features which makes the graph look more complicated, but also enhance it for readability and help get a story across.\nGeometries along with aesthetics can produce a graph that is readable, and without one or the other, a graph cant exist. Scales can enhance aesthetics because you have control on how you want aesthetics to be displayed. Without scales, ggplot will do it for you, but it may not be in a way you want. Transformations help shape your data ggplot can’t naturally do. It means changing your data, which can enhance the datas usefulness by removing unneeded data, which can make a graph more clustered and hard to read. So, it overall helps with making data more suitable for plotting. Statistical elements will help display this change of data, which means it can be analysed and can be compared to geometrics for raw data, which can help with pattern recognition. Coordinates help pin-point aspect ratios and how you layout where you want your scales. You define aesthetics, scales to display visuals in a way you want, then coordinates helps you with how to lay the scales out. Then guides will help with navigation and providing text to what each part means. This enhances a graphs readability and ease of viewing. Then facets help with comparsion. Without them, data-points would over-lap, data is clustered which makes it harder to notice more specific trends. This can enhance decision making and overall analysis."
  },
  {
    "objectID": "grammar_of_graphics.html#references",
    "href": "grammar_of_graphics.html#references",
    "title": "Explaining the Grammar of Graphics",
    "section": "References",
    "text": "References\nHadley.W., Garett.G., and Cetinkaya-Rundel, M. (2023) R For Data Science. Sebastopol; O’Reilly Media\nLeland Wilkinson (2005) Statistics and computing: The Grammer of Graphics (Second Edition). New York; Springer\nhttps://rgbcolorpicker.com/ (Accessed: 09/12/2025)\nhttps://vle.harper-adams.ac.uk/course/view.php?id=287 (Accessed: 09/12/2025)\nhttps://www.isixsigma.com/methodology/categorical-vs-continuous-data-whats-the-difference/ (16/12/2025)\nhttps://vle.harper-adams.ac.uk/course/view.php?id=287 (Accessed: 22/12/2025)\nhttps://vle.harper-adams.ac.uk/course/view.php?id=287 (Accessed: 22/12/2025)\nVinod Chugani (2024) Choosing the Optimal Bin Size for Your Histogram. Available at: https://www.statology.org/choosing-the-optimal-bin-size-for-your-histogram/ (Accessed: 23/12/2025)\nUniversity of Colorado Boulder (2021) A Grammer of Graphics. Available at: https://www.youtube.com/watch?v=RCaFBJWXfZc (Accessed: 22/12/2025)\nNumberAnalytics (2025) The Ultimate Guide to Standard Error in Stats. Available at: https://www.numberanalytics.com/blog/ultimate-guide-standard-error-stats (Accessed: 28/12/2025)\nhttps://vle.harper-adams.ac.uk/course/view.php?id=287 (Accessed: 02/01/2026)\nhttps://vle.harper-adams.ac.uk/course/view.php?id=287 (Accessed: 06/01/2026)\nAI has been used in this document (For research and definitions then written in my own words, helping with troubleshooting coding issues)"
  },
  {
    "objectID": "Planning_a_complex_graph.html",
    "href": "Planning_a_complex_graph.html",
    "title": "A Complex Graphic in Practice",
    "section": "",
    "text": "GGplot is a library in R Studio. It’s a tool that was made based on the theory of the grammar of graphics. The grammar of graphics is a list of components that you will need to make a complex graphic. These components combined allow you to create complicated and more personal graphs. The components of the grammar of graphics are data, transformations, scales, coordinates, elements and guides. GGplot using R programming to accomplish this. I will now use these principles to make a complex graph."
  },
  {
    "objectID": "Planning_a_complex_graph.html#introduction",
    "href": "Planning_a_complex_graph.html#introduction",
    "title": "A Complex Graphic in Practice",
    "section": "",
    "text": "GGplot is a library in R Studio. It’s a tool that was made based on the theory of the grammar of graphics. The grammar of graphics is a list of components that you will need to make a complex graphic. These components combined allow you to create complicated and more personal graphs. The components of the grammar of graphics are data, transformations, scales, coordinates, elements and guides. GGplot using R programming to accomplish this. I will now use these principles to make a complex graph."
  },
  {
    "objectID": "Planning_a_complex_graph.html#complex-graphic-in-practice",
    "href": "Planning_a_complex_graph.html#complex-graphic-in-practice",
    "title": "A Complex Graphic in Practice",
    "section": "Complex Graphic in Practice",
    "text": "Complex Graphic in Practice\n\nlibrary(\"ggplot2\")\n\nWarning: package 'ggplot2' was built under R version 4.5.2\n\nggplot(iris, aes(Sepal.Length, Sepal.Width, colour = Species)) +\n  geom_point() +\n  scale_colour_manual(values = c(setosa = \"red\", versicolor = \"blue\", virginica = \"orange\")) +\n  labs(title = \"Sepal Length vs Sepal Width\", x = \"Length\", y = \"Width\") +\n  facet_wrap(~Species) \n\n\n\n\n\n\n\n\nThe first section of my graph is data. I have chosen to use the iris data-set within R Studio. I have then declared what aesthetics i want. I have chosen my x and y axes to be Sepal.Length and Sepal.Width. I then used scales to change the colours of the data values for each specific specie. I then included labels to my graph, adding a title and re-naming my axes. This graph embodies the grammar of graphics by including data, which is where I declare the name of the data-set I’m working with. I then declare what aesthetics I want. I then use scales, which is where I change the colours for each specie. I also use elements, which is my geometric (point). I then include guides which is my labels and facets. I have done each component in the right order, so it follows the rules of the grammar of graphics.\n\nggplot(iris, aes(Sepal.Length, Sepal.Width, colour = Species)) +\n  geom_boxplot() +\n  scale_colour_manual(values = c(setosa = \"red\", versicolor = \"blue\", virginica = \"orange\")) +\n  labs(title = \"Sepal Length vs Sepal Width\", x = \"Length\", y = \"Width\") +\n  facet_wrap(~Species) \n\nWarning: Orientation is not uniquely specified when both the x and y aesthetics are\ncontinuous. Picking default orientation 'x'.\n\n\n\n\n\n\n\n\n\nThis has the same data and components as the first graph but has a different geometric. I have now used box plots instead of points. Box plots show distribution of data, where as points show every data-point, meaning its best for comparison. Box plots are best for simple viewing, giving viewers the main idea. points are best for in-depth analysis and comparison. Since box plots don’t show every data-point, you can’t accurately analyse it. This is because box plots can sometimes hide trends, so you get the wrong conclusion. Being able to see each data-point will let you see everything. Box plots are simpler to read however, since they have less components on them, so they seem less overwhelming. Points are a bit more overwhelming for a general viewer, and data-point placements can look messy .\n\nggplot(iris, aes(Sepal.Length, Sepal.Width, colour = Species)) +\n  geom_point() +\n  scale_colour_manual(values = c(setosa = \"red\", versicolor = \"blue\", virginica = \"orange\")) +\n  labs(title = \"Sepal Length vs Sepal Width\", x = \"Length\", y = \"Width\") +\n  facet_grid(Species~Petal.Width) \n\n\n\n\n\n\n\n\nThis graph now has a different facet. I have made a grid facet. A grid facet is where you use two values to facet. In the original graph, I have a facet wrap. This separates data into the values in the variable you declare. For example, if you declared years, you will have an individual graph for each year, each graph only showing data relevant to that year. For grids, it uses two variables. The first variable you declare will be rows, and the next will be columns. Here, each petal width value has its own graph, for each specie. Facet grids can easily overwhelm viewers if there are a lot of columns and rows. Facet wraps aren’t as overwhelming because there are less graphs because there’s no columns. Facet wraps are also better for general viewing and presentations. This is because the way wraps are designed, viewers typically look at each graph one at a time, meaning it can tell a story better. It’s like reading a book, each graph being a page. Grids however are better for in-depth analysis. Since you have organised the data-points into many categories, you can notice trends easier and get more specific, which is best for analysing data."
  },
  {
    "objectID": "Planning_a_complex_graph.html#references",
    "href": "Planning_a_complex_graph.html#references",
    "title": "A Complex Graphic in Practice",
    "section": "References",
    "text": "References\nLeland Wilkinson (2005) Statistics and computing: The Grammer of Graphics (Second Edition). New York; Springer\nhttps://vle.harper-adams.ac.uk/course/view.php?id=287 (Accessed: 12/01/2026)\nAI has been used in this document (Used for troubleshooting coding issues)"
  },
  {
    "objectID": "index.html#introduction",
    "href": "index.html#introduction",
    "title": "Data Visualisation",
    "section": "",
    "text": "This website has been designed to teach you about data visualisation in R, more specifically ggplot. R is a programming language that is used for statistics. GGplot is a library within R that lets us utilise the grammar of graphics. The grammar of graphics is a structure that is used to make complex graphs. Data visualisation is presenting your data in a visual form. If you own a huge company, you may make graphs to show how much money you made over the fiscal year. This is data visualisation. You have data on your revenue earnings, then you present it on a graph. This data could show you had a slow start of the year, but then got better towards the end. This is shown in your data visualisation. Instead of speaking about it, you can show people it instead. In the data science world, data visualisation is a rare skill. Many data scientists can use the data, but can’t present it well. So, this website will do that. It will cover data visualisation, covering specifications, the grammar of graphics, how complex graphs look and how choosing different components can change how data is shown and how animation can be used to elevate your graph."
  },
  {
    "objectID": "animation_in_a_graphic.html",
    "href": "animation_in_a_graphic.html",
    "title": "Animation with gganimate",
    "section": "",
    "text": "Animation is most well known in the entertainment industry. It’s used heavely for childrens media like television shows and movies. It has also been used in media like video games and promotion material. The basic premise of animation is showing images in rapid succession to create an illusion of movement. The objects in the images move slighty every image. Animation can also be used in mediums peoples don’t usually think about. This is for graphs. Graphs can create animations for their data-values. I will now present how this can be done"
  },
  {
    "objectID": "animation_in_a_graphic.html#introduction",
    "href": "animation_in_a_graphic.html#introduction",
    "title": "Animation with gganimate",
    "section": "",
    "text": "Animation is most well known in the entertainment industry. It’s used heavely for childrens media like television shows and movies. It has also been used in media like video games and promotion material. The basic premise of animation is showing images in rapid succession to create an illusion of movement. The objects in the images move slighty every image. Animation can also be used in mediums peoples don’t usually think about. This is for graphs. Graphs can create animations for their data-values. I will now present how this can be done"
  },
  {
    "objectID": "animation_in_a_graphic.html#animation-in-graphs",
    "href": "animation_in_a_graphic.html#animation-in-graphs",
    "title": "Animation with gganimate",
    "section": "Animation in graphs",
    "text": "Animation in graphs\n\nlibrary(\"gapminder\")\n\nWarning: package 'gapminder' was built under R version 4.5.2\n\nlibrary(\"ggplot2\")\n\nWarning: package 'ggplot2' was built under R version 4.5.2\n\nlibrary(\"gganimate\")\n\nWarning: package 'gganimate' was built under R version 4.5.2\n\np &lt;- ggplot(gapminder, aes(gdpPercap, lifeExp, colour= continent)) +\n  geom_point() +\nlabs(title = \"Year: {frame_time}\", subtitle = \"Africas HIV/AIDS epidemic in 1990s\")\nanim &lt;- p + transition_time(year) + ease_aes('linear')\nanim\n\nanimate(anim, fps = 15)\n\n\n\n\n\n\n\nanim_save(\"gapminder.gif\", animation = anim)\n\n##(code inspired by: https://vle.harper-adams.ac.uk/course/view.php?id=287)\n\nThis graph shows the life expectancy and GDP per capita for every country for years between the 1950’s and 2007. Here you can see that the points are now animated. Before, the points doesn’t move. But now, the points move as the years go on. This animation can change your visual perception. This is because animations on graphs make a story more interesting. Think of static graphs like books. Books can tell great stories, but they may not be as captivating, because books rely on imagination to make readers immersed. Movies however, do that for you. They provide a visual and movement. This is a similar idea to animations in graphs. If the points are moving slowly, we may perceive it as not much change/not important, however if the points suddenly jolts up/down, we know its more important. Its like in movies when an action scene plays. We notice it and remember it more because its fast-paced and has loud music. (Idea generated from Hans Roslings augmented reality graph YouTube video).\nViewers may also notice patterns more with animation. Animation will speed up according to how drastically the data changes. If it suddenly goes up/down, the animation will be faster. Because of this, viewers will feel the impact more. Since the animation plays so fast, it suddenly appears to viewers. This will make viewers shocked/surprised with the sudden speed, so they recognise that this change may be good or bad. With a still graph, viewers don’t get that same sudden acceleration as the data changes, so it may feel less significant of a change.\nIn the 1990s, early 2000s, there was a HIV/AIDS epidemic in Africa. This heavily impacted Africa’s life expectancy, as in Botswana and Zimbabwe, over half of their deaths were caused by HIV/AIDS (Hannah Ritchie). However treatments such as antiretrovil therapy reduced deaths and caused Africas life expectancy to go back up sightly (as seen in graph). We have noticed this change much easier with the help of animations. This is because animations can accelerate when data declines significantly, meaning its more noticeable."
  },
  {
    "objectID": "animation_in_a_graphic.html#refereneces",
    "href": "animation_in_a_graphic.html#refereneces",
    "title": "Animation with gganimate",
    "section": "Refereneces",
    "text": "Refereneces"
  },
  {
    "objectID": "animation_in_a_graphic.html#references",
    "href": "animation_in_a_graphic.html#references",
    "title": "Animation with gganimate",
    "section": "References",
    "text": "References\nhttps://vle.harper-adams.ac.uk/course/view.php?id=287 (Accessed: 13/01/2026)\nHannah Ritchie, At the peak of the HIV epidemic. AIDS caused more than half of all deaths in some countries. Available: https://ourworldindata.org/data-insights/at-the-peak-of-the-hiv-epidemic-aids-caused-more-than-half-of-all-deaths-in-some-countries (Accessed: 13/01/2026)\nHans Rosling (2010) Hans Roslings 200 Countries. 200 years, 4 minutes. Available at: https://www.youtube.com/watch?v=jbkSRLYSojo (Accessed: 13/01/2026)"
  }
]